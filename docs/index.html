<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>VaporSpace</title>
  <link rel="shortcut icon" href="https://raw.githubusercontent.com/Mess663/cloud-image/master/img/20200412110352.png"></head>

<body>
  <header class="header">
    <a class="header__name">VaporSpace</a>
    <a class="header__index">首页</a>
  </header>
  
  <div class="list">
    
      <a href="/blog/0.html" class="list-item">
        <h2 class="list-item__title">git魔法：HEAD的指针变化</h2>
        <p class="list-item__desc"> 一、HEAD是什么？
在git中撤回操作，无论是reset、checkout和revert撤回上一步，都会用到HEAD这个指令字段，但这个HEAD到底指得是什么，一直没搞明白。其实一开始在学git原理的时候，都会看到下面这种图。

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5f337e9c4b?w=546&amp;h=338&amp;f=png&amp;s=78941)

告诉你HEAD是一个指针，如果你用`cat .git/HEAD`这个命令查看HEAD，就会知道这里存储的是当前分支，如：`ref: refs/heads/master`。

但正如每个git入门教程里说的，这个`refs/heads/master`里存储其实就是当前commit的引用。这里可以理解为一个仓库就是一颗树，每个分支则是不同的树枝，树枝上有不同的节点（代表每一个commit），而commit之前也有父子关系，HEAD指针则是指向commit id，HEAD所在的commit就是目前本地仓库的状态。

那平时我们提交commit则是增加节点，同时HEAD指针后移，这个不必多说。但git的强大，不止如此，还可以通过reset、checkout、revert、merge和rebase等操作指令，花式移动指针，游走于整颗commit树，这个是这次笔记的重点。

 二、merge和rebase
merge是合并分支，rebase是整合分支（个人理解），是直接将分支信息整合进一个链条，这样的好处是看起来简洁。通常的操作是现在短期分支上rebase目标分支，然后在将短期分支merge进去。虽然rebase之后的分支看起来很整洁一贯，但正因为rebase强行将commit整合，就会出现下图这样提交时间先后不分的情况，git统一的处理是将合并进来的分支所有提交放在最前端；

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5d9d484bcf?w=882&amp;h=494&amp;f=png&amp;s=52203)

当然，对于某些洁癖来说，rebase确实是个救星，就算是在`--no-ff`这种带分支信息的合并中，用了rebase，也能将一个分支的提交单独提出到一个分叉中，看起来比较直观，不会跟主分支里的提交混淆，不过如果说是一个健康的主分支一般也不会出现这种混淆的情况（分支内直接push），所以这里也就是提一提。

但实际上rebase的使用是有原则的，就是不要将私有分支的提交rebase到公共分支，因为这样会导致共有分支的提交记录改变（rebase的原理就是对比合并分支并将commit一一合并，从而用新的commit去覆盖），这样对其他协作者非常不利。可参考rebase的使用：https://cn.atlassian.com/git/tutorials/merging-vs-rebasingthe-golden-rule-of-rebasing

如果再带上`squash`命令，就可以直接把被合并分支中的所有commit合并成一个，提交记录就更简洁了，不过可能无法追溯细节提交记录，并且回滚也比较麻烦。

 三、reset、checkout、revert
开发的时候，经常需要进行提交撤回的操作，一般用到这三个指令，他们的区别是：
1、reset只更改HEAD指针指向的commit id，如果这个操作撤回某些commit，则这些commit在log里会消失，并且这些commit引用会在git的垃圾回收处理过程中被删除，也就是这部分树枝之后会被锯掉；
2、checkout则为移动的目标指针单独建立一个分支，并移动HEAD，原分支不变；
3、revert新建一个commit，指针后移，并将目标commit的内容作为本次commit的内容，个人感觉这种操作更安全，毕竟会保留之前的记录；(但是要注意，如果你合并了某个分支，并且revert该分支中的一个commit，不要以为再合并一次这个分支就可以还原那个revert，是不行的，git会默认把这个revert导致的差异对冲掉，你如果想还原，要么reset或者revert那次revert)

下面是三种命令的使用场景总合，来源：https://cn.atlassian.com/git/tutorials/resetting-checking-out-and-reverting
![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5dbf2c829c?w=1206&amp;h=682&amp;f=png&amp;s=134646)


 四、~ 和 ^
这两个符号在三中的操作中，经常会用到，个人理解为移动指针的单位。一中提到，commit之间存在父子关系，当commit是一条链没有分叉时，父子关系是递增下去的。如果是中间有合并操作，则上一次合并操作为父亲（暂时怎么理解，我了解的也不够深）。

所以从下面两张图可以看到，^n 符号是父亲节点中找第n-1个（因为^1就是当前节点），像这里^2则是到第一个父亲节点，^3是第二个，如果^4则会报错，因为不存在第三个父亲节点。

而 ~n 则是往上找到n-1层到第一个节点，~2则是找到父亲节点，~3则找到爷爷节点。

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5da67ae8db?w=1038&amp;h=596&amp;f=png&amp;s=113135)
（c1是曾爷爷）

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5dc0f8de79?w=1534&amp;h=330&amp;f=png&amp;s=111473)
![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5da5e6a9da?w=1206&amp;h=244&amp;f=png&amp;s=70784)

截图里的操作序列，还少了一个比较重要的点，就是`git reset HEAD~`命令会将HEAD移动到当前commit的第一个父亲节点（9b13a6c 合并），所以从上两个图可以看出，^和~的区别，但目前本人很少遇到用到这两个命令的场景，也暂不了解这两个命令有什么高级的用法，所以点到为止。

 五、cherry-pick
这个命令也是一个很好用用的改变commit的指令，如这个指令名，它的作用就是将一个或多个commit捡出（pick），然后合并进当前分支。有点git merge some commit的意思。

 六、git update-ref
命令用于更新一个指针文件中的Git对象ID。

在理解这个命令前，需要先了解一下git 的refs文件（http://www.chenchunyong.com/2017/01/06/git-refs-%E8%AF%A6%E8%A7%A3/）

我的理解是，git的refs文件，就是存储git下的各种管理分支的引用，同时远程分支和本地分支的追踪也是依靠这个文件。

我会去了解这个是因为遇到下面这个问题，git在创建新分支时，因为分支名为`hotfix/1129`，但由于前面refs的实现的原理，本地之前有一个hotfix分支，而这个hotfix分支在`.git/refs/heads/hotfix`这里标记了一个ref，而创建hotfix/1129时，则是想覆盖`.git/refs/heads/hotfix`这个文件为`.git/refs/heads/hotfix/1129`，这么做git自然不允许，所以报错 `refs/heads/hotfix exists`。

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5da37fad2a?w=1116&amp;h=48&amp;f=png&amp;s=8987)

知道了原因后，解决方法有两个，一是使用` git update-ref -d refs/heads/hotfix`去删除hotfix的refs；二是直接删除hotfix这个分支，因为`refs/heads/hotfix`这里其实就是对hotfix分支的引用；

但个人觉得真正的原因就是这个命名导致的，因为出现了hotfix这种过于简单且不符合项目规范的命名，又没有及时删除导致的。因为这次错误是出现在测试人员那里，所以项目最好规范开发不允许取这种简单的分支名，或者不采用 / 符号来做分支划分，可以用 _ 等代替。

 七、git revert
将一个操作撤回，并将这次撤回当作一个commit。这么做的好处有很多：
- 这次撤回操作可追溯；
- 相比直接reset，这个不需要强制push远程，因为这是增量操作。如果是reset，远程commit是多于本地的，这时候需要force push才能使远程同步，这个过程如果有人提交了远程就炸了；

如果是revert一次merge的话，需要带上-m %d 命令，表示你需要撤回的阶级，是这次merge还是merge中的某次commit，我的理解就是上面HEAD笔记里提到的父子commit概念；</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/1.html" class="list-item">
        <h2 class="list-item__title">git魔法｜git的HEAD和HEAD的指针变化</h2>
        <p class="list-item__desc"> 一、HEAD是什么？
在git中撤回操作，无论是reset、checkout和revert撤回上一步，都会用到HEAD这个指令字段，但这个HEAD到底指得是什么，一直没搞明白。其实一开始在学git原理的时候，都会看到下面这种图。

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5f337e9c4b?w=546&amp;h=338&amp;f=png&amp;s=78941)

告诉你HEAD是一个指针，如果你用`cat .git/HEAD`这个命令查看HEAD，就会知道这里存储的是当前分支，如：`ref: refs/heads/master`。

但正如每个git入门教程里说的，这个`refs/heads/master`里存储其实就是当前commit的引用。这里可以理解为一个仓库就是一颗树，每个分支则是不同的树枝，树枝上有不同的节点（代表每一个commit），而commit之前也有父子关系，HEAD指针则是指向commit id，HEAD所在的commit就是目前本地仓库的状态。

那平时我们提交commit则是增加节点，同时HEAD指针后移，这个不必多说。但git的强大，不止如此，还可以通过reset、checkout、revert、merge和rebase等操作指令，花式移动指针，游走于整颗commit树，这个是这次笔记的重点。

 二、merge和rebase
merge是合并分支，rebase是整合分支（个人理解），是直接将分支信息整合进一个链条，这样的好处是看起来简洁。通常的操作是现在短期分支上rebase目标分支，然后在将短期分支merge进去。虽然rebase之后的分支看起来很整洁一贯，但正因为rebase强行将commit整合，就会出现下图这样提交时间先后不分的情况，git统一的处理是将合并进来的分支所有提交放在最前端；

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5d9d484bcf?w=882&amp;h=494&amp;f=png&amp;s=52203)

当然，对于某些洁癖来说，rebase确实是个救星，就算是在`--no-ff`这种带分支信息的合并中，用了rebase，也能将一个分支的提交单独提出到一个分叉中，看起来比较直观，不会跟主分支里的提交混淆，不过如果说是一个健康的主分支一般也不会出现这种混淆的情况（分支内直接push），所以这里也就是提一提。

但实际上rebase的使用是有原则的，就是不要将私有分支的提交rebase到公共分支，因为这样会导致共有分支的提交记录改变（rebase的原理就是对比合并分支并将commit一一合并，从而用新的commit去覆盖），这样对其他协作者非常不利。可参考rebase的使用：https://cn.atlassian.com/git/tutorials/merging-vs-rebasingthe-golden-rule-of-rebasing

如果再带上`squash`命令，就可以直接把被合并分支中的所有commit合并成一个，提交记录就更简洁了，不过可能无法追溯细节提交记录，并且回滚也比较麻烦。

 三、reset、checkout、revert
开发的时候，经常需要进行提交撤回的操作，一般用到这三个指令，他们的区别是：
1、reset只更改HEAD指针指向的commit id，如果这个操作撤回某些commit，则这些commit在log里会消失，并且这些commit引用会在git的垃圾回收处理过程中被删除，也就是这部分树枝之后会被锯掉；
2、checkout则为移动的目标指针单独建立一个分支，并移动HEAD，原分支不变；
3、revert新建一个commit，指针后移，并将目标commit的内容作为本次commit的内容，个人感觉这种操作更安全，毕竟会保留之前的记录；(但是要注意，如果你合并了某个分支，并且revert该分支中的一个commit，不要以为再合并一次这个分支就可以还原那个revert，是不行的，git会默认把这个revert导致的差异对冲掉，你如果想还原，要么reset或者revert那次revert)

下面是三种命令的使用场景总合，来源：https://cn.atlassian.com/git/tutorials/resetting-checking-out-and-reverting
![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5dbf2c829c?w=1206&amp;h=682&amp;f=png&amp;s=134646)


 四、~ 和 ^
这两个符号在三中的操作中，经常会用到，个人理解为移动指针的单位。一中提到，commit之间存在父子关系，当commit是一条链没有分叉时，父子关系是递增下去的。如果是中间有合并操作，则上一次合并操作为父亲（暂时怎么理解，我了解的也不够深）。

所以从下面两张图可以看到，^n 符号是父亲节点中找第n-1个（因为^1就是当前节点），像这里^2则是到第一个父亲节点，^3是第二个，如果^4则会报错，因为不存在第三个父亲节点。

而 ~n 则是往上找到n-1层到第一个节点，~2则是找到父亲节点，~3则找到爷爷节点。

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5da67ae8db?w=1038&amp;h=596&amp;f=png&amp;s=113135)
（c1是曾爷爷）

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5dc0f8de79?w=1534&amp;h=330&amp;f=png&amp;s=111473)
![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5da5e6a9da?w=1206&amp;h=244&amp;f=png&amp;s=70784)

截图里的操作序列，还少了一个比较重要的点，就是`git reset HEAD~`命令会将HEAD移动到当前commit的第一个父亲节点（9b13a6c 合并），所以从上两个图可以看出，^和~的区别，但目前本人很少遇到用到这两个命令的场景，也暂不了解这两个命令有什么高级的用法，所以点到为止。

 五、cherry-pick
这个命令也是一个很好用用的改变commit的指令，如这个指令名，它的作用就是将一个或多个commit捡出（pick），然后合并进当前分支。有点git merge some commit的意思。

 六、git update-ref
命令用于更新一个指针文件中的Git对象ID。

在理解这个命令前，需要先了解一下git 的refs文件（http://www.chenchunyong.com/2017/01/06/git-refs-%E8%AF%A6%E8%A7%A3/）

我的理解是，git的refs文件，就是存储git下的各种管理分支的引用，同时远程分支和本地分支的追踪也是依靠这个文件。

我会去了解这个是因为遇到下面这个问题，git在创建新分支时，因为分支名为`hotfix/1129`，但由于前面refs的实现的原理，本地之前有一个hotfix分支，而这个hotfix分支在`.git/refs/heads/hotfix`这里标记了一个ref，而创建hotfix/1129时，则是想覆盖`.git/refs/heads/hotfix`这个文件为`.git/refs/heads/hotfix/1129`，这么做git自然不允许，所以报错 `refs/heads/hotfix exists`。

![](https://user-gold-cdn.xitu.io/2020/4/12/1716de5da37fad2a?w=1116&amp;h=48&amp;f=png&amp;s=8987)

知道了原因后，解决方法有两个，一是使用` git update-ref -d refs/heads/hotfix`去删除hotfix的refs；二是直接删除hotfix这个分支，因为`refs/heads/hotfix`这里其实就是对hotfix分支的引用；

但个人觉得真正的原因就是这个命名导致的，因为出现了hotfix这种过于简单且不符合项目规范的命名，又没有及时删除导致的。因为这次错误是出现在测试人员那里，所以项目最好规范开发不允许取这种简单的分支名，或者不采用 / 符号来做分支划分，可以用 _ 等代替。

 七、git revert
将一个操作撤回，并将这次撤回当作一个commit。这么做的好处有很多：
- 这次撤回操作可追溯；
- 相比直接reset，这个不需要强制push远程，因为这是增量操作。如果是reset，远程commit是多于本地的，这时候需要force push才能使远程同步，这个过程如果有人提交了远程就炸了；

如果是revert一次merge的话，需要带上-m %d 命令，表示你需要撤回的阶级，是这次merge还是merge中的某次commit，我的理解就是上面HEAD笔记里提到的父子commit概念；</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/2.html" class="list-item">
        <h2 class="list-item__title">JavaScript那些不应该被忽视的细节</h2>
        <p class="list-item__desc"> 一、JavaScript作为解释型语言如何运行
- 引擎：负责整个JavaScript代码的编译和执行
- 编译器：做分词、语法解析析、生成引擎的执行代码（虽然JavaScript是解释型语言，但也是有编译过程的）
- 作用域：管理和维护所有的声明和变量，并确定当前执行的代码对哪些变量有访问权限
&gt; 作用域像一个辅助，编译时收集和管理变量，引擎执行时又要决定哪些变量能被访问

 二、词法作用域
作用域分两种，词法作用域和动态作用域。大部分编程语言都使用第一种，包括JavaScript。词法作用域决定于变量和块作用域写在哪，它是在编译器解析词法的过程中就确定的。这个作用域的目的是辅助引擎编译和执行代码。

我的理解就是通过花括号来判断词法作用域，所以它是由代码书写的范围来决定的。

当然在JavaScript中可以通过with和eval来动态改变词法作用域，但不推荐，因为动态的作用域让引擎执行时不能更好地进行优化，所以会对性能造成影响。

 三、函数作用域与闭包
是JavaScript最常见的作用域，一个函数的内部信息是对外隐藏的，但却能访问到外部信息，所以嵌套函数也会形成作用域链。利用这个特性可以使用自执行函数和闭包。

 四、块作用域
不同于函数作用域，块作用域在JS中比较少见，以前只有在with和catch中会形成块作用域，内部的声明不能被外部引用。后来出现了let和const，它们声明的变量可以绑定在当前的花括号为块的作用域内，但并非生成块作用域。

 五、声明提升
因为在编译器运行的过程中，会根据词法定义好作用域，在这个过程中一个变量的声明和赋值会被挺升至作用域顶部，而函数声明则更加厉害，声明和赋值都被提升。

这么做的目的个人猜测是因为JS作为一个灵活的脚本语言，这种设置能够智能地减少报错，但随着JS程序的扩大这种“小聪明”式的特性会带来一些意想不到的bug，与此类似的还有重复使用var声明同一变量，因为编译器会首先去查找在本作用域内是否早有声明，有则直接覆盖，并不是真正意义上的重复声明。为了解决这些副作用，es6推出了let和const来进行变量声明，摒弃了上面这些特性。

 六、this指向
函数调用时，会创建一个执行上下文来记录所有信息，包括调用栈、调用方式等，而this就是其中一个属性，指向调用对象。这也意味着，this是在函数调用时决定的。

这也是为什么初学者会对this指向有疑惑，因为它不同于作用域链是在词法分析阶段就确认的，this是动态的，所以会让人困扰。而箭头函数正是为了解决这个问题，箭头函数不绑定调用对象，而是通过作用域链找到上一次层的this。

四个确定this指向的操作，按优先级顺序排列：
1. new绑定对象；
2. call、apply、bind显式绑定；
3. 对象属性直接调用；
4. 普通函数调用，隐式绑定全局对象，如果是严格模式则绑定undefined。

 七、对象
以前我一直有两个疑惑，一是为什么JS有string、number等基础类型，他们与对象Object是不同的，为何它们也有属性和方法；二是为什么要有String、Number等构造器来构造对应的对象，却还需要所谓的基础类型？

第一个问题的原因是，当声明一个字符串如`var s = &#39;abc&#39;;`然后取`s.length`的时候，其实引擎自动帮我们将基础类型string转成String对象，所以自然就拥有里length属性。至于第二个问题，应该是考虑到内存的优化问题，毕竟基础类型只要存在栈上，也不像对象需要一个构造的过程，有性能的优势。

对象有属性描述符，顾名思义，就是对对象属性进行描述或者说规定。通常使用`Object.defineProperty`来进行配置，有`value、writable、enumerable、configurable`，通过这四个属性可以控制这个对象属性的增删改查。

[[GET]]是每个对象都会有的一个内置方法，用于访问属性，每次访问属性时都相当于`GET()`，有一个细节是，这个方法在本对象拿不到属性时，会尝试在原型链上查找。对应的还有个[[PUT]]内置方法，用于设置属性。

上面两个配置方法也可以被属性中的Getter和Setter来代替，这个同样也是由开发者通过`Object.defineProperty`修改的。其实Getter和Setter被称为访问描述符，通过设置对象属性的Getter和Setter也可以达到控制属性增删改查的效果，只是更灵活。

 八、原型链
每个对象都有个[[prototype]]内置属性，他指向对象的原型，也就是原型链的形态。那么为什么需要原型呢？这是我一直的疑问，因为它虽然听起来很方便，可以向上找到属性，但却给这门语言带来了难以理解的复杂性。

如果说编程可以创造世界，那么我们为了避免重复描述，一般都会将一些通用描述“封装”起来，比如交通工具一般都有引擎，这是动力的来源，那么我们在创造汽车、轮船、飞机的时候就不需要去重复描述引擎这件事，因为是个交通工具就肯定有引擎的呀。那么我认为原型存在的目的就是去“封装”某些描述，这有点像类和类继承的概念。但是类继承其实是一个复制的方式，因为父子类是互不关联的，但原型链并不是。

而且由于JavaScript中一切皆对象，为了保证性能复制对象其实只是复制引用地址，所以自然而然地就出现原型链这种方式，以关联对象的方式达到“继承”的目的，原型链就是这种思想下的产物。

当你尝试去拿某个对象的属性时，会调用其内部方法[[GET]]，它会先查找本对象，找不到再往原型链上找。

同样的设置属性值也是，当你设置`myObj.foo=123`时，会先查找myObj本身是否有，有则覆盖。myObj本身没有的话，我以前以为会直接添加，但实际并不是，它依然会先找原型链，如果上一级对象有相同属性则直接屏蔽掉它，再在myObj上添加，这听起来跟直接添加从结果上来说差别不大，但问题是当原型链上设置的同名属性是不可写的则这个操作不会进行下去，而是会报错（严格模式）或直接静默失败，如果原型链上设置了setter则会直接调用这个setter而不会在myObj上添加foo。使用defineProperty可以避免这个小问题。

 九、Promise
在es6之前，异步操作都是跟JavaScript的宿主环境有关，所以异步操作往往是在的某个线程进行之后再通知js执行回调。但是es6引入了事件循环机制，同时把异步管理纳入了js引擎的范畴。

那么为什么需要引进时间循环或者说为什么需要promise呢？这主要是为了解决js传统的异步回调带来的问题:回调地狱以及回调的不确定性。promise的then和catch能清晰地描述异步步骤解决回调地狱。而promise.then只调用一次也避免了异步回调的不稳定性（回调的调用者可能不受控，可能被调用多次或者吞掉错误）。

promise意为承诺，承诺给你一个结果，拿到结果我就做接下来的事，而回调是将我要做的事告诉对方等他愿意做的时候再帮我做，他会做几次、会不会出错我都不确定。简单来说，用回调来处理异步事件是一件存在很多坑的事。

还有一些点，如promise.all解决多异步共享结果，race解决竞态，promise里只有同步操作也必须入队列解决同步代码导致执行顺序预期不正确。这些都是锦上添花的语法糖。

promise的错误处理有一点需要注意：
```js
// Promise.resolve会将传入参数promise化，如果传入的参数带有then属性，则会直接将其promise化并展开调用
p = Promise.resolve(123) 
p.then((res) =&gt; {
    throw Error() // 报错
    console.log(res) // !!这里永远不会执行
}, (err) =&gt; {
    // 我以为这里会执行，但不会。因为p.then实际会返回一个默认的Promise.resolve(undefined)
    // 所以p和p.then是两个单独的promise，故这个reject回调不会被调用
    console.log(&#39;error 1&#39;) 
}).then(() =&gt; {
    console.log(&#34;这里会执行吗&#34;) // 并不会执行
    // 实际这个then里会默认补充一个rejected回调: (err) =&gt; Promise.reject(err)
    // 所以报错error会继续传递下去
}).catch((err) =&gt; {
    // 这里才会catch到p.then的错误
    console.log(&#39;error 2&#39;)
})

// 结果：error 2
```

 十、事件循环
JavaScript会维护一个执行栈，把所有函数的上下文合成一个栈帧压入栈，执行完后出栈，而关于异步的操作事件则是维护一个队列，循环去取出队列中的回调压入栈。

当执行栈清空后就开始清队列，规则是在每个循环中，不断对队列执行下面三个步骤：
- 执行一次宏任务（所有运行在外部事件源的任务，这里指浏览器的DOM操作、Ajax、用户交互、History Api、定时器、script标签的执行）
- 执行队列内所有的微任务（es6后加入的Promise和MutationObserver）
- 渲染页面
```js
setTimeout(() =&gt; {
  console.log(&#39;setTimeout 1&#39;);
  
  Promise.resolve().then(() =&gt; {
    console.log(&#39;Promise 3&#39;);
  }).then(() =&gt; {
    console.log(&#39;Promise 4&#39;);
  });
});

Promise.resolve().then(() =&gt; {
  console.log(&#39;Promise 1&#39;);
}).then(() =&gt; {
  console.log(&#39;Promise 2&#39;);
});
console.log(&#39;start&#39;)

setTimeout(() =&gt; {
  console.log(&#39;setTimeout 2&#39;);
});

/
    结果：
    &#34;start&#34;
    &#34;Promise 1&#34;
    &#34;Promise 2&#34;
    &#34;setTimeout 1&#34;
    &#34;Promise 3&#34;
    &#34;Promise 4&#34;
    &#34;setTimeout 2&#34;
/
```
这里有一点要注意，按我上面的循环步骤，应该至少要先执行一次宏任务（setTimeout）才对，为什么还是先执行了所有Promise的结果，原因是这段代码会运行在&lt;script&gt;标签里，而这个标签的运行是一次宏任务。所以我之前一直误解是微任务先执行。</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/3.html" class="list-item">
        <h2 class="list-item__title">为什么React需要Hook？</h2>
        <p class="list-item__desc">&gt; 在使用一段时间的hook后，可以说hook对开发体验有很大的改进，解决了以前的痛点。

 优点

1. 生命周期化作钩子，可以在函数组件内自由使用，逻辑聚合、复用方便；
2. 自定义hook代替高阶组件，更优雅简洁；
3. 不用声明繁杂的类组件，不需要this，可以简化一些代码；

&gt; 但是hook的出现也有一些争议，hook的改进并非完美无缺的，还需要社区去探索一个最佳实践。

 缺点：

1. 会增加一定心智负担，因为使用useEffect不像以前的生命周期那么直观，需要考虑到依赖的影响，还需要考虑跨渲染次数的数据存储，如果使用不当或者没有做好缓存会经常出现频繁渲染的问题；
2. 因为太灵活，所以团队合作如果大家对hook的熟悉程度不同，写出来的代码上下限会更大；

 class转变为函数

我觉得React在一开始使用类来声明组件，一方面是这个很直观，当你想到状态、方法和渲染函数的集合时，第一反应会是用一个类来承载，另一方面是这也让使用者更好上手，API比较直观容易理解。

类组件的主体是这个类，渲染函数只是其中一部分，但其实并不是每个组件都需要一个复杂的实例，真正的主体应该是那个组件不可或缺的渲染函数，所以其实将一个渲染函数作为一个组件主体才是正确的做法。

于是从类组件到函数组件，只需要将类中的上下文抽离出来，将render函数作为主体，通过钩子的方式为函数组件提供生命周期的访问能力。

 为什么是这些hook

以前一般我们不会在render函数里放任何副作用代码，因为我们知道render函数会经常重复执行。所以需要引入useEffect来解决这个问题，通过闭包的方式记录下副作用代码，并在DOM渲染完成后执行它。再通过声明依赖的方式去告诉React何时更新并执行这个闭包，很好地代替了mount和update生命周期。

所以一个useEffect实际上是要告诉React，一个函数需要依赖什么状态，并在渲染后执行这个函数。

但光有useEffect和useState还是不够的，函数组件会在每一次渲染重新执行，意味着我们还需要一个能在多次渲染中存储数据的能力，这是用来代替原来class this的部分功能，它就是useRef。至于useMemo和useCallback都是基于useRef的实现，主要起到通过缓存减少渲染次数的作用。

而useReducer则更多的是对状态管理的补充，useState使得状态声明分散，粒度控制比较头疼，加入useReducer，可以将同类型的状态优雅的归类在一起。其他hook都只是一些能力补充，而自定义hook则增强了逻辑的分层和抽象能力，让react hook真正的健壮起来。

有一点需要注意的是，因为hook脱离渲染函数，所以他是怎么确定每个hook的引用呢？答案是首先通过use前缀的约定标记hook，再根据调用顺序来维护引用，每当调用了hook，则把之前存储好的对应顺序位置的引用拿出来即可，这也是为什么hook不允许被条件判断包裹的原因，这会导致hook调用顺序不一致。

增加的这些API确实是给了另一种思维方式，现在整个函数有的只是每一次渲染，所有的hook都是围绕着每一次渲染去执行的。

&gt; 对React的理解尚浅，有错误之处，请务必指出，谢谢！</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/4.html" class="list-item">
        <h2 class="list-item__title">常见排序算法详解（JavaScript实现）</h2>
        <p class="list-item__desc"> 1、选择排序

   时间复杂度：O(n^2)
    
   原理：通过两层循环来实现，外层遍历整个数组，内层再遍历一次数组并找到未排序数组中的最小数组（通过迭代比较，不停去相对最小值），然后将最小值与第一个数组项对调，接着外循环进入第二轮，便从第二项数组开始重复上述操作，直到整个数组排列完毕；


![](https://user-gold-cdn.xitu.io/2020/3/20/170f89899da5bc69?w=607&amp;h=319&amp;f=png&amp;s=22653)

 2、插入排序

   时间复杂度：O(n^2)
    
   原理：依然要通过两层循环，外循环便利每个数组项，内循环从外循环的数组项（i）开始往前遍历，如果当前数组项比前一个小，则与前一个调换位置，这样一直循环重复，数组就逐渐归位了；
    
   其实本质上跟选择排序一样，通过两个循环来排序，插入排序虽然在内循环次数上一般会比选择排序边际递减地快，但也付出了大量的数组转换的操作；（代码下图①）
    
   理论上来说插入和选择两种排序实际效率应该相近，但事实并非如此，在随机的数据表现上，插入排序是明显慢于选择排序，这主要是因为插入排序中大量的数组项值调换赋值的操作；
    
   所以接下来要改进插入排序，减少数组项调换复制操作，替代为单向复制，在内循环中不再是比前一位小就调换，而是先将 j（当前项） 的值取出，将 j-1 的值复制进目前的 j 项中，先不改变 j-1 的值，然后再拿当前项去跟 j-2 比，如果当前项还是更小，则重复之前操作，直到正确位置，再将当前项的值复制进去，这样就成功减少了近一半的赋值操作了；（代码下图②）
    
   事实证明，优化过的插入排序，在十万随机数据级别已经领先排序一半了，更何况插入排序在找到正确位置后就会停止循环，对随机性较低的数据则有更大优势；（如下图）
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f898da6ca8f30?w=149&amp;h=57&amp;f=png&amp;s=1829)

插入和选择的性能比较^

![](https://user-gold-cdn.xitu.io/2020/3/20/170f89904d95385f?w=594&amp;h=331&amp;f=png&amp;s=22775)

①改进前 ^

![](https://user-gold-cdn.xitu.io/2020/3/20/170f899319ca14df?w=600&amp;h=433&amp;f=png&amp;s=29850)

②改进后 ^

 3、冒泡排序

   时间复杂度：O(n^2)
    
   冒泡排序依然是两层循环，跟选择和插入排序思路差不多，就是外循环遍历，内循环不断向后比较调换，两层循环结束后结果就排序好，这里就不再去实现了，都一个调性。
    

 4、希尔排序

   时间复杂度：最坏还是O(n^2)
    
   原理：希尔排序将插入排序作为它的子进程，它的核心是一个叫步长(gap)的概念，这个步长可以理解为一个类似疏密程度的概念。它共有3层循环，外层是以步长为循环，一般取数组的一半，循环一次再除一半，中层和里层就是插入排序的操作，不过不是跟前一项比，是跟当前索引减去步长后的那一项比。说到这里就可以理解为什么我说步长是类似疏密程度的概念，当步长不断除于2，变得越来越小，直到零停止循环，这个过程中，插入排序的比较项间越来越近，逐渐数组被排列出来。
    
   其实也是利用插入排序在数据随机性较低情况下很高校这个特点，随着步长降低，整个排序循环越来越高效。
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f89c390ace523?w=525&amp;h=445&amp;f=png&amp;s=31357)

   通过比较，在10W级的随机数据下，它的速度比前面的排序方法快的不是一点点，看下图。
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f89c69c46bef6?w=163&amp;h=63&amp;f=png&amp;s=2901)

   更直观的，可以看下图，来自维基百科；
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f896ded9ca521?w=277&amp;h=344&amp;f=gif&amp;s=276994)

 5、归并算法

   时间复杂度：最坏还是O(nlogn)；
    
   原理：归并算法可以分为两部分，第一部分就是将一个数组两两分开，递归进行，直到分到只剩下1个，这时候进行第二部分，也就是核心部分，将每个单独项与邻近项再两两归并，并且在归并后进行一个排序，最后不停往回归并，直到归并成一个有序的数组；
    
   那么这个归并后的排序怎么进行呢？我们知道，归并前有两个相邻数组，他们之间之前没有联系过，那怎么保证他们归并后是排好序的呢？首先将这两个要合并的数组成为arr1，然后再将这两个组数组复制一份成为arr2（再将arr1的两个数组合并），然后将arr2中两个数组从头开始依次以擂台的形式互比，谁小谁就先被赋值回arr1较前的位置，arr1从头往后按顺序赋值下去，直到排号序。最后通过这样递归的方式将整个数组排好序。我这里用了很多次“合并数组”这个词，但实际代码里为了性能更好，一般不会这样频繁操作数组，而是将数组的序号抽象出来，达到分开和归并的效果，具体代码看下图；
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f89cd6d329d88?w=342&amp;h=758&amp;f=png&amp;s=45898)

 6、快速排序

   时间复杂度：在某些最坏的情况下复杂度为O(n^2)，如果是完全随机就是O(nlogn)；
    
   原理：快速排序也是运用了分组递归的思想，首先找到这个分组的分界点（一般为当前数组首位），然后将这个分界点在数组中进行循环比较，最后让它回到它正确的位置，以此分界，分为两个数组递归下去，在这样的过程中逐渐完成排序。代码如下图。
    
   这里有一个很重要的一步是，在分界点进行循环比较时，需要将比它小的数往前移，就是下图for循环里的数组对调。
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f89f69295feca?w=453&amp;h=511&amp;f=png&amp;s=31231)

   在原理中，我提到，分界点一般取首位，但如果遇到近乎有序的数据时，就会出现O(n^2)的时间复杂度，要优化这一点，很简单，只要分界点去随机位就行，这样出现最坏情况的可能性虽然仍然会存在，但极低了，如下图；
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f89fe26443ee5?w=557&amp;h=524&amp;f=png&amp;s=35766)

   还有一种情况就是如果数据中存在大量重复，也会导致递归分组下去会出现像上面那样分组极端不平衡的情况，最终时间复杂度会出现最坏的情况。为了解决这种情况，需要进行双向遍历，这次循环比较分界点分别从头尾两个方向同时进行，小等于分界点和大于等于分界点的被分别纳入两个分组，这样就能一定程度上将重复的数据分开。具体实现看下图，只改动了mid的取值，所以单独写了一个函数来取值；
    

![](https://user-gold-cdn.xitu.io/2020/3/20/170f8a0109a9226b?w=697&amp;h=497&amp;f=png&amp;s=43605)</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/5.html" class="list-item">
        <h2 class="list-item__title">微信小程序代码转头条小程序踩坑分享</h2>
        <p class="list-item__desc">我们公司的微信小程序代码由于迭代了比较久，应用了很多微信小程序的新特性以及使用webpack，所以用头条的搬家工具转换之后，仍然不能直接运行。主要面临两个问题：1、头条小程序不支持分包，采用流加载；2、头条不支持wxs，并且没有替代品。


为了解决第一个问题我魔改了一位大佬开源的百度小程序搬家工具（头条的搬家工具没开源）。地址：[v-wx2toutiao](https://github.com/Mess663/v-wx2toutiao)

这个工具主要做了下面4件事：
- 利用头条搬家工具转换api和模版等差异；
- 将分包加入进主包（修改文件位置和app.json）；
- 将ttml、ttss、js、json所涉及到的所有依赖路径进行调整；
- 因为头条小程序ttml中使用include引入模版不会继承作用域，所以将inlude的源代码替换进来；


至于第2个wxs的问题我暂时没有想到比较好的解决方法，只能手动去修改成js。改好这两个问题，基本可以初步跑通。

----

还有一些其他小坑，在这里提醒一下：
- 没有nextTick，建议用setTimeout代替
- ios 不支持真机调试
- 父元素 catchtouchmove 触发会导致子元素 scroll-view 无法滚动
- [ios] textarea 用在 hidden 判断隐藏，真机显示后不能输入文字
- 组件内不可声明 pageLifetimes
- component 没有 observe
- [iphoneX] 部分有 padding 的 view 会出现溢出，设置 box-sizing: border-box 即可解决，就算全局给 view 标签选择器加 box-sizing: border-box 也没用，必须加在类选择器下。
- [android] 设置自定义导航栏，导航栏标题依然会出现
- [ios] tt.chooseImage 选择图片，不知道出于什么目的，自动会将图片格式转为 jpeg 格式，并且在临时链接加上一些参数后缀，导致我上传七牛失败
- 开发者工具在不同系统里的表现不一样，我遇到都是 mac，同版本的开发者工具，结果对 css !import 的支持却是不一样的。


还想吐槽一下，头条小程序的社区实在是太不用心了，很多开发者的提问连回复都没有。遇到问题，一搜大家都有遇到，就是没有官方回应，心态崩了。</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/6.html" class="list-item">
        <h2 class="list-item__title">翻译｜揭示现代浏览器原理(1) — Chrome官方</h2>
        <p class="list-item__desc">&gt; 原文：[Inside look at modern web browser (part 1)](https://developers.google.com/web/updates/2018/09/inside-browser-part1)

 CPU, GPU, 内存, 以及多进程架构
这个系列共有4篇，我们将会从Chrome浏览器的高层架构谈到到渲染管道的细节。如果你曾好奇浏览器是怎么将你的代码生成网页，或者你不清楚一些性能优化的实践是建立在哪些原理上的，那这个系列就是为你而准备的。
翻译｜揭示现代浏览器原理(1) — Chrome官方
在这一篇，我们将会谈一些关于计算核心的术语和Chrome的多进程架构。

&gt; ★ 提醒：如果你对CPU/GPU的概念和进程/线程这些概念比较熟悉，可以跳到[浏览器架构](浏览器架构)的部分

 CPU和GPU是计算机的核心
为了更好了解浏览器运行的环境，我们需要先讲讲计算的部分构成以及它们的作用。

 CPU
首先是中央处理器，英文简称CPU。可以理解为计算机的大脑，由若干个核（即运算单元）组成。可以把CPU的核想象成一个社畜，当接到不同的任务时，他会一个一个地去处理（如下图）。从数学计算到图形处理，只要他知道如何处理你的需求，他都会搞定。以前，大多数CPU都是独立的芯片（即没有集成内存、GPU等），一个核更像是同块芯片内的另一个CPU。现代硬件里，通常都是多核的CPU，并且集成了除计算以外的能力，让手机和电脑拥有更强的算力。
&gt; 注：CPU一般会有多个核，就是市面上宣传的双核、四核等概念。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf5eb0aa84e447cd943656672444e8fa~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;CPU的每个核像社畜一样在办公桌上等着任务进来&lt;/div&gt;
&lt;/center&gt;

 GPU
图形处理单元，英文简称GPU，是计算机的另一个组成部分。不像CPU，GPU则擅长利用多核同时处理单一的任务。通过名字可以知道，它就是为了处理图像而生的。这也就是为什么图像的渲染速度和交互流畅度，经常与“GPU使用”和“GPU支持”这些内容所关联。近些年，利用GPU加速，GPU可以独自完成越来越多的计算工作。

&gt; 这里补充一下，引用网上的通俗比喻，CPU是一个博士啥都懂，显卡是千万个小学生同时计算一个公式。CPU只能一件件的解算，显卡可以千万（上亿）个同时解算。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f66c098a9ca3470aba449c137758034c~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;许多GPU核拿着扳手，意味着它们每个只能做有限的工作&lt;/div&gt;
&lt;/center&gt;

当你在电脑或手机启动并运行一个应用程序，这个过程需要CPU和GPU来完成，通常这个过程有操作系统的调度机制去处理。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2310bc85e4f34216be8b588e3a140fed~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;计算机架构分三层：硬件在底层提供能力，操作系统在中间调度，应用程序在最上层运行&lt;/div&gt;
&lt;/center&gt;

 通过进程和线程执行程序
在讲浏览器架构前，还有一个概念需要掌握，就是进程与线程。进程可以理解为一个正在运行的程序。线程则存在进程中，去执行进程中程序的各个部分。

当你启动一个程序，就创建了一个进程，这个程序会选择性地创建若干个线程去干活。在运行程序的过程中，操作系统会分配给进程“内存块”，是这个程序私有的内存空间，用来存储程序的相关状态。当你退出程序，则进程消失，操作系统会将它之前占用的内存释放。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2616113a72a74c7abab606bb73d437df~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;进程是一个盒子，线程则可以想象成盒子里畅游的鱼&lt;/div&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;br&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b4ce278fc364d2597965023128a8954~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;a style=&#34;text-decoration: underline;&#34; href=&#34;https://developers.google.com/web/updates/images/inside-browser/part1/memory.svg&#34;&gt;点击查看动画：使用内存空间并存储应用程序数据的过程&lt;/a&gt;
    &lt;br&gt;
    &lt;br&gt;
&lt;/center&gt;

一个进程可以要求操作系统启动另一个进程来运行不同的任务。发生这种情况时，将为新进程分配不同的内存。如果两个进程间需要交换信息，它们可以通过进程间通讯机制（IPC）来实现。许多应用程序都有多进程设计，每个模块功能开一个进程，这样如果一个进程故障了，还能保证其他正常运行。

&lt;center&gt;
    &lt;br&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0daccd195126402ba419c04807f358a6~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;a style=&#34;text-decoration: underline;&#34; href=&#34;https://developers.google.com/web/updates/images/inside-browser/part1/workerprocess.svg&#34;&gt;点击查看动画：图解多进程通讯&lt;/a&gt;
    &lt;br&gt;
    &lt;br&gt;
&lt;/center&gt;

 浏览器架构
那么一个网页浏览器是怎么通过进程和线程构建出来的呢？简单来说，他可以是由一个进程和许多不同的线程组成，也可以是许多不同的进程和一些通过IPC通讯的线程。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c32de28b456f496794ad213bd2c06b16~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;基于进程/线程的不同浏览器架构&lt;/div&gt;
&lt;/center&gt;

需要说明的是，浏览器架构是没有一个标准的，以上都是两种实现方案，不同浏览器间的架构可能会有天壤之别。

而在这个系列，我们将会针对Chrome浏览器最近版本的架构，用图解的方式来讲解浏览器架构。

浏览器有一个主进程，他与负责其他模块的进程协作。对于渲染进程，它会被创建多次并分配给每个分页（tab）。目前，Chrome的调度机制是尽可能给每个分页单独创建一个渲染进程，现在还在尝试给每个网站创建单独的进程，包括iframe。（[详情点击查看](https://developers.google.com/web/updates/2018/09/inside-browser-part1site-isolation)）

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8b168d67d44762874847804221f312~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;Chrome多进程架构：图中渲染进程（Render Process）有多层，表示Chrome创建了多个渲染进程为每个分页服务&lt;/div&gt;
&lt;/center&gt;

 进程的分工是怎样的呢？
详见下表：
| 进程的分工  ||
| --------   | -----  | 
| 浏览器主进程 | 控制着一些交互上的功能，如地址栏、书签、前进后退按钮。当然也包括浏览器底层的控制，如网络请求和文件操作权限  |
| 渲染        |   控制分页内，网页展示的一切   |  
| 插件        |    控制浏览器所使用的插件，如flash    | 
| GPU        |    脱离其他进程，单独完成图像处理任务。它还会被分解成多个进程，用于处理不同应用的需求，并将其绘制在同一个面板上   | 

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b994078af314cebb004bc7009c9320c~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;不同的进程指向不同的模块&lt;/div&gt;
&lt;/center&gt;

还有更多进程没有提到，如扩展程序进程和浏览器工具进程。如果你想看看有哪些进程运行在你的Chrome上，点击右上角菜单按钮 -&gt; 更多工具 -&gt; 任务管理器。就会打开一个窗口展示给你看，现在有哪些进程在运行，分别消耗了多少CPU和内存资源。

 Chrome多进程架构的优势
前面，我提到Chrome使用多渲染进程。你想象一下，在大多数情况下，Chrome为每个分页（tab）单独创建一个渲染进程。比如有三个分页，如果其中一个卡住了，那么你可以关掉它，继续使用其他分页。如果所有分页共用一个进程，那很不幸，挂一个全遭殃。

&lt;center&gt;
    &lt;br&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94a8565d03f4c49beff62480b714213~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;a style=&#34;text-decoration: underline;&#34; href=&#34;https://developers.google.com/web/updates/images/inside-browser/part1/tabs.svg&#34;&gt;点击查看动画：分页拥有单独渲染进程&lt;/a&gt;
    &lt;br&gt;
    &lt;br&gt;
&lt;/center&gt;

多进程架构另一个优势是安全性和沙盒。因为操作系统提供了限制进程权限的方法，所以浏览器可以将某些进程隔离起来。例如，像渲染进程这种需要处理用户输入的进程，Chrome会限制它对任意文件的访问权限。

因为这些进程都有自己专门的内存空间，他们通常会拷贝一份通用的基础工具库进去（比如Chrome的JavsScript解析引擎V8）。这意味着，如果不是同一进程里的线程则不能共享这些基础工具库，造成了内存浪费。为了减少这种浪费，Chrome对进程的数量会有所限制，具体取决于你设备的CPU和内存。当Chrome开的进程数达到了设定的极限，它会开始将同一个网站的分页（tab）运行在同一个进程中，不再为每个分页单独开进程。

 节约更多内存 - Chrome的服务化
Chrome正在进行架构更改，将这个成熟的方案运用在浏览器的进程管理中，以将浏览器程序的每个部分作为一项服务运行，从而可以轻松拆分为不同的进程或聚合为一个进程。

大概就是当Chrome跑在高性能的机子上，它会将功能服务拆分进不同的进程，从而获得更高的稳定性。相反，如果跑在一些“小霸王”上，则将服务聚合到一个进程上以减少内存占用。在Chrome的这次调整之前，Android平台已经运用这套方案将进程合并来降低内存占用。

&lt;center&gt;
    &lt;br&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89b2c559625f48c686b10255e94c13b8~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;a style=&#34;text-decoration: underline;&#34; href=&#34;https://developers.google.com/web/updates/images/inside-browser/part1/servicfication.svg&#34;&gt;点击查看动画：服务在多进程和单进程间切换&lt;/a&gt;
    &lt;br&gt;
    &lt;br&gt;
&lt;/center&gt;

 分站渲染进程 - 站点隔离
[站点隔离](https://developers.google.com/web/updates/2018/07/site-isolation)是最近被引进Chrome的特性，为每个站点（即网站）开一个单独的渲染进程。之前谈到每个分页（tab）单独开一个渲染进程，允许不同站点在其中运行，并共享内存空间。a.com和b.com运行在同一个渲染进程，因为有[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)的存在，它是web的核心安全模型，它保证了两个站点间在没有对方允许的情况下，不可以传输数据。但这样还是有隐患，网站安全攻击常常会以绕过此安全策略为首要目标，所以解决这种隐患最有效的方案就是站点隔离。再加上出现[溶毁和幽灵漏洞](https://developers.google.com/web/updates/2018/02/meltdown-spectre)，就更需要将站通过不同进程分开。从桌面版Chrome 67开始，分页内跨站点的iframe都默认会为其单独开一个渲染线程。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acccb4cd0d404df9bdde070566c28f24~tplv-k3u1fbpfcp-zoom-1.image&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;分页内不同站点的iframe都被分配了单独的渲染进程（Render Process）&lt;/div&gt;
&lt;/center&gt;

使站点互相独立是多年工程攻坚的成果，这并不仅仅是分配渲染进程这么简单。它改变了iframe间通信的底层实现，在运行有若干个iframe的页面，每个iframe有自己的进程，当你按F12打开chrome开发者工具时，Chrome后台需要做许多工作才能使开发者工具的启动无缝衔接。哪怕只是简单地用 Ctrl+F 检索全文，也需要通过搜索不同进程中的内容来得到准确结果。这也是为什么浏览器工程师谈起站点隔离时，会说这是个重要的里程碑。

 总结一下
这篇文章，我们纵览了浏览器的架构和了解了多进程架构的优势。也看到了Chrome的服务化和站点隔离跟多进程架构的紧密联系。[在下一篇，进程与线程时如何合作去展示一个网页的。](https://developers.google.com/web/updates/2018/09/inside-browser-part2)

```!
如有翻译错误，欢迎指正
```</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
      <a href="/blog/7.html" class="list-item">
        <h2 class="list-item__title">翻译｜揭示现代浏览器原理(2)：网页访问 — Chrome官方</h2>
        <p class="list-item__desc">&gt; 原文：[Inside look at modern web browser (part 2)](https://developers.google.com/web/updates/2018/09/inside-browser-part2step_1_handling_input)

 网页访问过程中发生了什么
这是揭秘浏览器原理系列的第二篇，[在上一篇](https://juejin.im/post/6844904082348441614)，我们讲解了浏览器如何利用不同的进程和线程去运作对应功能模块。本文会更深入地探讨不同的进程和线程是如何协作来展示一个网页的。

当你在浏览器输入一个网址，浏览器会从互联网获取倒数据，并将其展示出来。这篇文章将会重点讲用户输入地址到浏览器准备渲染网页的这个过程。

 从浏览器主进程开始
在第一篇[CPU、GPU、内存和多进程架构](https://developers.google.com/web/updates/2018/09/inside-browser-part1)中，我们提到tab页以外的一切都在浏览器的主进程中运转。浏览器的主进程里包括有负责绘制导航栏上按钮和输入框等UI的线程，有负责网络数据获取的线程，有控制文件操作权限的存储线程等。当你输入一个URL到地址栏时，这个输入过程是由浏览器主进程中的UI线程来处理。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/17197016382ebfbb?w=865&amp;h=504&amp;f=png&amp;s=62722&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;UI线程、存储线程和网络处理线程&lt;/div&gt;
&lt;/center&gt;

 网页访问
 第一步：处理输入
当用户在地址栏输入时，UI线程需要先知道输入的是搜索关键词还是URL？在谷歌浏览器里，地址栏同时也是搜索框，所以UI线程会先解析输入内容，再决定是跳转搜索引擎还是输入的地址。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/1719701632d32bc1?w=865&amp;h=504&amp;f=png&amp;s=52557&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;UI线程判断是搜索关键词还是URL&lt;/div&gt;
&lt;/center&gt;

 第二步：开始跳转
当用户按下回车键，UI线程会将网址传给网络处理线程，让其初始化网络调用准备去拿网页内容。这时当前tab标签的一角会有加载中的菊花动画，网络线程则要通过一系列协议，如DNS查询和建立TLS连接来发起请求。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/171970163326d427?w=865&amp;h=504&amp;f=png&amp;s=63579&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;UI线程通知网络处理线程将要跳转到mysite.com&lt;/div&gt;
&lt;/center&gt;

有时候，网络处理线程也许会从服务器那收到一个重定向的响应头，如HTTP 301（永久重定向）。在这种情况下，网络处理进程会告知UI线程服务器请求重定向，接下来，另一个URL请求将会被初始化。

 第三步：读取响应数据
拿到响应数据后，网络线程将在必要时查看数据流前面的若干个字节。响应头的Content-Type（媒体类型）字段会说明这是什么类型的数据，如果这个字段不存在，则会进行媒体类型嗅探，[源码](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&amp;dr=CS&amp;l=5)里的注释说嗅探这个操作很棘手，因为需要考虑很多东西。如果你想了解不同的浏览器是如何处理媒体类型和数据有效载荷的，你可以去看一下源码的注释。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/171970163f067269?w=720&amp;h=363&amp;f=png&amp;s=37422&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;在响应头中的Content-Type（媒体类型）和有payload（有效载荷，即真正需要用到的数据）&lt;/div&gt;
&lt;/center&gt;

如果请求返回的是HTML文件，那下一步就是将其传给渲染进程。但如果是压缩文件或其他类型的文件，则意味着这是个下载文件的请求，那就要将文件数据交给下载管理器了。

这个环节还会做[浏览安全检测](https://safebrowsing.google.com/)，如果域名或返回数据跟系统黑名单匹配上了，那网络处理线程会展示一个警告页面。并且，跨域限制检查也会触发，以保证跨域敏感数据不会进入渲染线程。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/1719701633ddfbd7?w=865&amp;h=504&amp;f=png&amp;s=67622&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;网络线程判断返回数据是否为HTML？并来自安全的站点&lt;/div&gt;
&lt;/center&gt;

 第四步：准备渲染进程
一旦所有的检查都通过了，网络线程确定目标网站是安全的，就会告诉UI线程所有数据都准备就绪了。接下来，UI线程就会让已经初始化好的渲染进程开始处理页面。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/171970164b395809?w=865&amp;h=504&amp;f=png&amp;s=68929&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;网络线程告诉UI线程可以开始让渲染进程工作了&lt;/div&gt;
&lt;/center&gt;

因为网路线程去请求数据通常需要几百毫秒，为了充分利用这个时间空档，当在第二步UI线程将URL传给网络线程后，UI线程就马上异步地去为这个URL查找或创建一个渲染进程。如果一切进行顺利，则这个准备好的渲染进程就能在网络请求完成后立马开始工作。但如果进行了跨站重定向，则之前预先准备的渲染进程将不会被使用，而是针对新的网址重新创建。

 第五步：完成跳转
当数据和渲染进程都准备好了，浏览器主进程会通过IPC（进程间通信）通信，把HTML数据以数据流的方式持续传输给渲染进程。一旦浏览器主进程收到渲染进程接受完毕的确认后，这次跳转就完成了，进入文档加载阶段。

此时，地址栏会更新，网站安全标示和网站设置UI会根据当前网站的信息来显示。tab的访问历史会更新，也就是前进/后退键会去到之前访问过的地方。为了保证tab的访问记录之后还能恢复，这个历史记录将会保存进硬盘。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/171970171f502c98?w=865&amp;h=504&amp;f=png&amp;s=79984&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;浏览器住进程和渲染进程件的IPC（进程间通信）&lt;/div&gt;
&lt;/center&gt;

 额外的步骤：初始化加载完成
跳转完成后，渲染进程还需要继续加载资源和渲染页面。在[下一篇文章](https://developers.google.com/web/updates/2018/09/inside-browser-part3)中，我们将详细介绍此阶段发生的情况。当渲染进程“结束”渲染，它会通过IPC（进程间通信）告知浏览器主进程（这是在所有onload函数，包括iframe内的，都执行完毕后才进行的通信）。收到信息后，浏览器主进程内的UI线程将会停止tab上的loading的菊花动画。

上面说“结束”带了双引号，是因为客户端的JavaScript此时依然可以加载额外的资源和渲染新的试图。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/1719701720fd24be?w=865&amp;h=504&amp;f=png&amp;s=69282&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;渲染进程告诉浏览器主进程加载完成&lt;/div&gt;
&lt;/center&gt;


 跳转至不同的站点
至此，一个简单的网页访问完成了。但如果用户在地址栏再输入一个不同的URL会怎么样呢？当然，浏览器进程还是会走跟上面同样的步骤。但在此之前，它需要检查当前网页是否有声明 [beforeunload](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) 事件。

在你关闭tab页时，beforeunload事件中可能会写有一些提醒之类的代码，如“是否确定离开此页”。tab下的所有东西包括JavaScript代码都是由渲染进程处理的，所以浏览器主进程在跳转其他页面时，需要检查一下这个渲染进程内是否声明了这个事件。

&gt; 注意：如非必要，不要随便声明 beforeunload 事件，因为只有在执行完这个事件后才能跳转下一个页面，所以在此事件里添加了一些无条件执行的内容可能会造成潜在问题。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/171970172584612d?w=865&amp;h=504&amp;f=png&amp;s=78337&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;浏览器主进程告诉渲染进程需要跳转另一个页面了&lt;/div&gt;
&lt;/center&gt;

如果跳转是在渲染进程里发起的（比如用户点击跳转链接或JavaScript运行了```window.location = &#34;https://newsite.com&#34;```），渲染进程会先检查 beforeunload 事件，接下来就是走之前同样的步骤。唯一不同的是，这次跳转是由渲染进程去通知浏览器主进程。

当跳转到另一个站点，会加入另一个渲染进程来处理。当前的渲染进程还需要做一些收尾工作，如触发 unload 事件。更多内容，可以查看[页面生命周期一览](https://developers.google.com/web/updates/2018/07/page-lifecycle-apioverview_of_page_lifecycle_states_and_events)和通过[页面生命周期API](https://developers.google.com/web/updates/2018/07/page-lifecycle-api)了解如何使用钩子函数。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/1719701725d62e2b?w=865&amp;h=504&amp;f=png&amp;s=86452&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;浏览器主进程让新的渲染进程开始渲染，让老的结束&lt;/div&gt;
&lt;/center&gt;


 如果有Service Worker
跳转过程最近有一个新改动就是引入了[service worker](https://developers.google.com/web/fundamentals/primers/service-workers)。service worker可以让你在应用里搭建一个网络代理，方便控制需要缓存的数据和数据的新鲜度。如果service worker设置了可以读缓存，那就没必要去请求网络数据了。

但问题是，service worker是运行在渲染进程中的JavaScript代码，当访问一个网页时，浏览器主进程怎么知道是否存在service worker呢？

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/17197017325498da?w=877&amp;h=540&amp;f=png&amp;s=43019&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;浏览器主进程中的网络线程在询问是否有service worker&lt;/div&gt;
&lt;/center&gt;

当一个service worker被注册，它的作用域将被保存为一个引用。（更多关于作用域的信息可以参考这篇：[service worker生命周期](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)）跳转页面时，网络处理线程通过注册的service worker作用域去检查这个域名下是否注册有service worker，如果有就会引入渲染进程让它去执行service worker的代码。接下来，这个service worker开始运行，可能会从缓存取旧数据，免去请求，或者去请求新数据。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/171970177c95cba0?w=865&amp;h=504&amp;f=png&amp;s=79091&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;UI线程开启一个渲染进程去处理service worker；而渲染进程内的那个worker线程开始请求网络数据&lt;/div&gt;
&lt;/center&gt;


 导航预载
你可以想象一下，如果service worker最终需要请求网络数据，那浏览器主进程和这个渲染进程间的频繁通信会有很大延迟。而[导航预载](https://developers.google.com/web/updates/2017/02/navigation-preload)就是优化此问题的一个机制，它可以在service worker启动的同时异步地去加载资源。你在头部声明需要的请求，就会允许服务器为这些请求发送不同的内容，如只更新数据而不是整个文档。

&lt;center&gt;
    &lt;img style=&#34;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&#34; 
    src=&#34;https://user-gold-cdn.xitu.io/2020/4/20/17197017f98829d2?w=865&amp;h=504&amp;f=png&amp;s=73160&#34;&gt;
    &lt;br&gt;
    &lt;div style=&#34;color:orange; border-bottom: 1px solid d9d9d9;
    display: inline-block;
    color: 999;
    padding: 2px;&#34;&gt;UI线程启动了一个渲染进程来处理service worker，同时通知网络线程异步请求数据&lt;/div&gt;
&lt;/center&gt;


 总结
这篇文章，我们了解了跳转过程中的细节，和你的网页应用里响应头、客户端JavaScript等，是如何与浏览器交互的。说明了浏览器获取网络数据的步骤，让你更容易了解像导航预载这种API的作用。[下一篇](https://developers.google.com/web/updates/2018/09/inside-browser-part3)我们将会深入了解浏览器是如何执行HTML/CSS/JavaScript来渲染页面的。

```!
如有翻译错误，欢迎指正
```</p>
        <!-- <div class="list-item__time">2023-05-20 03:19</div> -->
      </a>
    
  </div>
<script type="text/javascript" src="/static/runtime.2ca5299c3fd6a2ec256c.js"></script><script type="text/javascript" src="/static/vendor.2ca5299c3fd6a2ec256c.js"></script><script type="text/javascript" src="/static/index.2ca5299c3fd6a2ec256c.js"></script></body>

</html>